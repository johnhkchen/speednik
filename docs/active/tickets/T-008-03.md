---
id: T-008-03
story: S-008
title: elemental-terrain-tests
type: task
status: open
priority: high
phase: done
depends_on: [T-008-01, T-008-02]
---

## Context

Write the elemental tests: micro-scenarios on synthetic grids that establish the mechanical
boundaries of the physics engine. Each test isolates one mechanic, uses a single strategy,
and makes a sharp assertion. Together they define what the engine can and cannot do.

These tests serve two purposes:
1. **Regression** — if a physics change breaks slope adhesion, the walkability test fails
2. **Design reference** — the test results document the engine's actual behavior (e.g.,
   "maximum walkable angle is byte 32 / ~45°"), which level designers need to know

### Test categories

**Ground adhesion**

```python
def test_idle_stays_grounded_flat():
    """Player on flat ground stays put for 600 frames."""
    result = run_scenario(build_flat(20, 10), 48.0, y, idle, 600)
    assert all(s.on_ground for s in result.snapshots)
    assert result.final.y == pytest.approx(result.snapshots[0].y, abs=0.5)

def test_idle_stays_grounded_slope():
    """Player on a 20° slope stays on_ground (may slide, but doesn't fall through)."""
    ...

def test_idle_stays_grounded_tile_boundary():
    """Player positioned exactly on a tile boundary stays grounded."""
    ...
```

**Walkability threshold**

```python
def test_hold_right_walks_20_degree_ramp():
    """hold_right should climb a 20° ramp without stalling."""
    ...

def test_hold_right_stalls_on_steep_ramp():
    """hold_right should fail to climb a 70°+ ramp (too steep for floor sensors)."""
    ...

@pytest.mark.parametrize("angle_deg", range(0, 91, 5))
def test_walkability_at_angle(angle_deg):
    """Sweep through angles to find the walkability threshold."""
    ...
    # Log the result for design reference; assert known boundary
```

The parametrized sweep finds the exact angle where `hold_right` transitions from "progresses"
to "stalls." This should be around byte angle 32 (~45°). The test asserts that angles below
the threshold are walkable and angles above are not.

**Speed gates**

```python
def test_spindash_clears_steep_ramp():
    """Spindash speed (8.0+) should clear a ramp that walking cannot."""
    ...

def test_walk_blocked_by_steep_ramp():
    """Walking speed (6.0 max) should not clear the same ramp."""
    ...

def test_downhill_boost_clears_obstacle():
    """Player starting from a height and rolling down should have enough speed."""
    ...
```

**Loop traversal envelope**

```python
def test_loop_traversable_with_ramps_at_spindash_speed():
    """Loop with entry ramps: spindash_right should complete full traversal."""
    lookup = build_loop(approach=20, radius=128, ground_row=40, ramp_radius=128)
    result = run_scenario(lookup, 48.0, y, spindash_right, 600)
    assert result.final.x > loop_exit_x
    assert result.quadrants_visited >= {0, 1, 2, 3}

def test_loop_without_ramps_blocks_player():
    """Loop without ramps: even spindash should fail (no angle transition)."""
    lookup = build_loop(approach=20, radius=128, ground_row=40, ramp_radius=None)
    result = run_scenario(lookup, 48.0, y, spindash_right, 600)
    assert result.final.x < loop_entry_x + 32  # stuck at entry

def test_loop_walk_speed_insufficient():
    """Loop with ramps at walking speed: player should fall off the side."""
    lookup = build_loop(approach=20, radius=128, ground_row=40, ramp_radius=128)
    result = run_scenario(lookup, 48.0, y, hold_right, 600)
    assert result.final.x < loop_exit_x  # didn't make it
```

**Gap clearing**

```python
@pytest.mark.parametrize("gap_tiles,strategy,should_clear", [
    (2, hold_right_jump, True),    # small gap, jumpable
    (6, hold_right_jump, True),    # medium gap, jumpable
    (12, hold_right_jump, False),  # large gap, too far
    (8, spindash_right, True),     # medium gap, spindash clears without jump
])
def test_gap_clearing(gap_tiles, strategy, should_clear):
    ...
```

### Location

`tests/test_elementals.py`

### Diagnostic output

When a test fails, the `ScenarioResult` should provide enough information to diagnose
without re-running: the frame where the player stalled, the angle at that frame, the
quadrant, whether on_ground, etc. Use `stuck_at()` and snapshot dumps in assertion messages.

## Acceptance Criteria

- [ ] Ground adhesion: idle on flat (600 frames), on slope, on tile boundary — all stay
  grounded, no Y drift
- [ ] Walkability threshold: parametrized angle sweep from 0° to 90° in 5° steps — tests
  pass below threshold, fail above
- [ ] Walkability threshold boundary documented as a constant or comment (expected ~45° /
  byte 32)
- [ ] Speed gate: spindash clears steep ramp that walking cannot
- [ ] Speed gate: downhill boost from height clears obstacle
- [ ] Loop with ramps + spindash: full traversal, all 4 quadrants visited
- [ ] Loop without ramps: player blocked (validates the bug S-007 describes)
- [ ] Loop with ramps + walk speed: player fails (loop requires speed)
- [ ] Gap clearing: parametrized gap sizes × strategies with expected outcomes
- [ ] All tests use synthetic grids from `tests/grids.py` (no real stage data)
- [ ] All tests use strategies from `tests/harness.py`
- [ ] No Pyxel imports
- [ ] `uv run pytest tests/test_elementals.py -x` passes
- [ ] Failed tests include diagnostic info (stall frame, angle, quadrant) in assertion
  messages
