---
id: T-010-16
story: S-010
title: directional-terrain-raycast
type: task
status: open
priority: high
phase: research
depends_on: [T-010-13]
---

## Context

Implement a directional raycast function that probes terrain from the player's position at
arbitrary angles. This extends the existing sensor infrastructure in `terrain.py` (which
casts in fixed axis-aligned directions) to support the observation vector's 7-ray fan.

See `docs/specs/scenario-testing-system.md` §3.2 (observation raycasts) and §9 Step 7.

### Terrain raycast function

```python
def cast_terrain_ray(
    tile_lookup: TileLookup,
    origin_x: float,
    origin_y: float,
    angle_deg: float,
    max_range: float = 128.0,
) -> tuple[float, int]:
    """Cast a ray from (origin_x, origin_y) at angle_deg (0=right, 90=down).
    Returns (distance_to_surface, surface_angle_byte).
    If no surface found within max_range, returns (max_range, 0)."""
```

### Implementation approach

The existing sensor functions (`_cast_sensor_down`, `_cast_sensor_right`, etc.) work along
axis-aligned directions. The terrain raycast needs arbitrary angles.

**Option A: Step-based raycasting.** Walk along the ray direction in small increments
(1-2 pixels), checking for tile occupancy at each step. When a solid tile is found, compute
the exact distance. Simple, reliable, ~64-128 iterations per ray at max_range=128.

**Option B: DDA (Digital Differential Analyzer).** Classic grid-traversal algorithm that
steps exactly from tile boundary to tile boundary. More efficient (fewer iterations) but
more complex. Used in Wolfenstein 3D-style raycasters.

**Recommendation**: Option A for initial implementation. 7 rays × 128 steps = 896 tile
lookups per frame. A tile lookup is a dict get — this is ~microseconds. Optimize to DDA
later only if profiling shows it matters.

### Ray angles

The observation uses 7 rays at angles relative to the player's facing direction:
`[-45, -30, -15, 0, 15, 30, 45]` degrees. The convention:
- 0° = horizontal (right if facing right, left if facing left)
- Positive = downward
- Negative = upward

The ray origin is the player's center (x, y - half_height).

### Edge cases

- Player in mid-air: rays may not hit anything within range → return (max_range, 0)
- Player inside a tile (rare, collision bug): first step hits immediately → return (0, angle)
- Ray exits level bounds: treat out-of-bounds as empty → return (max_range, 0)

### Location

- `speednik/terrain.py` — add `cast_terrain_ray` function, or
- `speednik/observation.py` — if keeping it separate from the core sensor code

Prefer `terrain.py` since it's closely related to the existing sensor infrastructure and
uses the same `TileLookup` abstraction.

## Acceptance Criteria

- [ ] `cast_terrain_ray` function with origin, angle, max_range parameters
- [ ] Returns (distance, surface_angle) tuple
- [ ] Distance is 0 to max_range (clamped)
- [ ] Surface angle is the byte angle (0-255) of the hit tile
- [ ] Ray at 0° (horizontal right) on flat ground returns distance to ground edge
- [ ] Ray at 90° (straight down) on flat ground returns distance to floor
- [ ] Ray in open air returns (max_range, 0)
- [ ] Ray into a wall returns short distance + wall angle
- [ ] Test on synthetic grids: flat, ramped, gap scenarios
- [ ] Performance: 7 rays in < 1ms (for 60fps budget)
- [ ] No Pyxel imports
- [ ] `uv run pytest tests/ -x` passes
