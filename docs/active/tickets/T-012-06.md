---
id: T-012-06
story: S-012
title: composable-mechanic-probes
type: task
status: open
priority: high
phase: done
depends_on: [T-012-01]
---

## Context

Stage-level audits (T-012-02 through T-012-04) test "can a player finish the level." But
levels are built from composable elements — loops, ramps, springs, gaps — and each element
has preconditions for correct behavior. If a loop can't be entered on a synthetic grid
under ideal conditions, it's broken as a building block. No amount of stage tuning will fix
a fundamentally broken mechanic.

This ticket tests mechanics in isolation using synthetic grids from `speednik/grids.py`.
Each probe asks: "given ideal conditions, does this element work?" Failures here are
engine/physics bugs, not level design issues.

### Your role

You are a QA auditor testing game mechanics as composable building blocks. Each probe
defines what SHOULD happen. If it doesn't, that's a finding about the engine, not the test.

### Mechanic probes

**1. Loop entry speed threshold**

The fundamental question: what minimum speed lets a player enter and complete a loop?

```python
def test_loop_enterable_at_spindash_speed():
    """A spindash (base speed 8.0) should be enough to enter and complete a loop."""
    tiles, lookup = build_loop(approach_tiles=15, radius=48, ground_row=20, ramp_radius=32)
    sim = create_sim_from_lookup(lookup, start_x=48.0, start_y=...)
    # Spindash, then hold right
    ...
    assert result.quadrants_visited == {0, 1, 2, 3}, "Loop not fully traversed"
```

If this fails, the loop geometry itself is broken — the angles, ramp transitions, or
collision resolution prevent entry regardless of speed. That's a finding about `build_loop`
or the physics engine, not about any particular stage.

**Parameterize across radii**: test loop radii 32, 48, 64, 96. All should be traversable
at spindash speed. Document which radii work and which don't.

**2. Loop exit preserves momentum**

After completing a loop, the player should exit with positive ground_speed and be on_ground.
If the player exits airborne or with negative speed, the exit ramp geometry is wrong.

**3. Ramp entry preserves speed**

```python
@pytest.mark.parametrize("end_angle", [10, 20, 30, 40, 50])
def test_ramp_entry_no_wall_slam(end_angle):
    """Running onto a ramp should not zero velocity."""
    tiles, lookup = build_ramp(approach_tiles=10, ramp_tiles=10,
                               start_angle=0, end_angle=end_angle, ground_row=20)
    ...
    # Assert: no frame where ground_speed drops from >1 to ~0
```

Parameterize across angles. Gentle ramps (10-20) should always work. Steep ramps (40-50)
may legitimately slow the player. The probe distinguishes "slowed by slope physics" from
"slammed into a wall" (velocity zeroing in a single frame).

**4. Gap clearability**

```python
@pytest.mark.parametrize("gap_tiles", [2, 3, 4, 5])
def test_gap_clearable_with_jump(gap_tiles):
    """A running jump should clear a gap of this width."""
    tiles, lookup = build_gap(approach_tiles=15, gap_tiles=gap_tiles,
                              landing_tiles=10, ground_row=20)
    ...
    assert not sim.player_dead, f"{gap_tiles}-tile gap should be clearable"
```

Establish the maximum gap a running jump can clear. Document the actual limit. If a 3-tile
gap is unclearable with a full-speed running jump, that's a physics issue (jump height or
horizontal distance too low).

**5. Spring launch height**

Using a synthetic grid with a flat surface and a manually placed spring:
- Walk into the spring
- Assert SpringEvent fires
- Assert player reaches expected height (based on SPRING_UP_VELOCITY constant)
- Assert player lands back on ground

If the spring doesn't launch to the expected height, the spring impulse or gravity is wrong.

**6. Slope adhesion sweep**

```python
@pytest.mark.parametrize("angle", range(0, 50, 5))
def test_slope_adhesion_at_angle(angle):
    """Player walking on a slope should stay on_ground."""
    tiles, lookup = build_slope(approach_tiles=10, slope_tiles=20,
                                angle=angle, ground_row=20)
    ...
    # Assert: player stays on_ground while on the slope surface
```

Sweep through angles 0 to ~50 (0° to ~70°). The player should maintain ground contact on
gentle slopes. Document the angle where adhesion fails — that's the engine's slope limit.

### Findings format

Same as other audit tickets. When a probe fails:
1. Keep the assertion as-is (what SHOULD work)
2. `@pytest.mark.xfail(reason="BUG: loop radius=48 not traversable at spindash speed")`
3. File a bug ticket with the specific mechanic, parameters, and failure mode

### What this tells us

A passing mechanic probe means: "this building block works, so if it fails in a real stage,
the problem is how the stage uses it." A failing probe means: "this building block is
broken, so every stage using it will inherit the bug."

This is the difference between "the hillside loop is broken" (stage bug) and "loops of
radius 48 are fundamentally broken" (engine bug).

### Location

`tests/test_mechanic_probes.py`
Bug tickets in `docs/active/tickets/T-012-06-BUG-*.md`

## Acceptance Criteria

- [ ] Loop probe: parameterized across radii (32, 48, 64, 96), tests entry/exit/traversal
- [ ] Loop probe documents minimum working radius and entry speed
- [ ] Ramp probe: parameterized across angles, distinguishes wall-slam from slope slowdown
- [ ] Gap probe: parameterized across widths, documents max clearable gap
- [ ] Spring probe: verifies launch height matches expected impulse
- [ ] Slope adhesion probe: sweep across angles, documents adhesion limit
- [ ] All probes use synthetic grids (speednik/grids.py), not real stage data
- [ ] Failing probes xfailed with bug tickets explaining the engine-level issue
- [ ] `uv run pytest tests/test_mechanic_probes.py -v` runs clean (xfails expected)
