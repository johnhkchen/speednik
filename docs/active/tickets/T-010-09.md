---
id: T-010-09
story: S-010
title: scenario-yaml-format-and-loader
type: task
status: open
priority: high
phase: research
depends_on: [T-010-06]
---

## Context

Define the YAML scenario format and build the loader that parses scenario definitions into
typed Python objects. Scenarios are declarative descriptions of "run this agent on this stage
and check these conditions."

See `docs/specs/scenario-testing-system.md` §5.1–5.2 for the format and condition types.

### Scenario definition format

```yaml
name: hillside_complete
description: Complete Hillside Rush from start to goal
stage: hillside
agent: spindash
agent_params:
  charge_frames: 3
  redash_speed: 0.15
max_frames: 3600
success:
  type: goal_reached
failure:
  type: player_dead
metrics:
  - completion_time
  - max_x
  - rings_collected
  - death_count
  - velocity_profile
```

### ScenarioDef dataclass

```python
@dataclass
class SuccessCondition:
    type: str                    # goal_reached, position_x_gte, alive_at_end, rings_gte
    value: float | None = None
    min_speed: float | None = None

@dataclass
class FailureCondition:
    type: str                    # player_dead, stuck, any
    tolerance: float | None = None
    window: int | None = None
    conditions: list[FailureCondition] | None = None

@dataclass
class StartOverride:
    x: float
    y: float

@dataclass
class ScenarioDef:
    name: str
    description: str
    stage: str
    agent: str
    agent_params: dict | None
    max_frames: int
    success: SuccessCondition
    failure: FailureCondition
    metrics: list[str]
    start_override: StartOverride | None = None
```

### Loader

```python
def load_scenario(path: Path) -> ScenarioDef:
    """Load a single scenario from a YAML file."""
    ...

def load_scenarios(paths: list[Path] | None = None, run_all: bool = False) -> list[ScenarioDef]:
    """Load multiple scenarios. If run_all, glob scenarios/*.yaml."""
    ...
```

Uses PyYAML (`pyyaml` dependency) or the stdlib `tomllib` equivalent — PyYAML is standard
for this. Add as a dependency.

### Condition types

From spec §5.2:

| Condition | Parameters | Semantics |
|-----------|-----------|-----------|
| `goal_reached` | — | Stage goal entity reached |
| `position_x_gte` | `value`, optional `min_speed` | Player x >= value |
| `position_y_lte` | `value` | Player y <= value (height) |
| `player_dead` | — | Player entered DEAD state |
| `alive_at_end` | — | Survived to max_frames |
| `stuck` | `tolerance`, `window` | Position variance < tolerance for window frames |
| `rings_gte` | `value` | Rings collected >= value |
| `any` | `conditions` | Compound: any sub-condition triggers |

### Initial scenario files

Write 3-5 starter scenarios:

- `scenarios/hillside_complete.yaml` — spindash agent, goal_reached
- `scenarios/hillside_hold_right.yaml` — hold_right agent, goal_reached (may fail)
- `scenarios/hillside_loop.yaml` — hold_right from near loop, position_x_gte past loop
- `scenarios/pipeworks_jump.yaml` — jump_runner agent, goal_reached
- `scenarios/gap_jump.yaml` — scripted agent, position_x_gte past gap

### Location

- `speednik/scenarios/__init__.py` — package init
- `speednik/scenarios/loader.py` — ScenarioDef, load_scenario, load_scenarios
- `speednik/scenarios/conditions.py` — condition dataclasses and type definitions
- `scenarios/` — YAML scenario files (project root)

## Acceptance Criteria

- [ ] `pyyaml` added as a dependency
- [ ] `ScenarioDef` dataclass with all fields
- [ ] `SuccessCondition` and `FailureCondition` dataclasses
- [ ] `load_scenario(path)` parses a YAML file into a ScenarioDef
- [ ] `load_scenarios(run_all=True)` finds all YAML files in `scenarios/`
- [ ] All 8 condition types parseable
- [ ] Compound `any` condition with nested sub-conditions works
- [ ] `start_override` optional field parsed correctly
- [ ] `agent_params` optional dict parsed correctly
- [ ] 3-5 starter scenario YAML files written
- [ ] Round-trip test: load a scenario, verify all fields populated
- [ ] No Pyxel imports
- [ ] `uv run pytest tests/ -x` passes
