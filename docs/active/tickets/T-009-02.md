---
id: T-009-02
story: S-009
title: live-bot-runner
type: task
status: open
priority: medium
phase: done
depends_on: [T-009-01]
---

## Context

Build the adapter that runs S-008 robotic player strategies live in the game loop, one
`player_update` per frame, renderable by Pyxel. This bridges the headless test harness
(strategies + `run_scenario`) and the visual game (renderer + camera).

### LiveBot class

```python
@dataclass
class LiveBot:
    player: Player
    strategy: Callable[[int, Player], InputState]
    tile_lookup: TileLookup
    camera: Camera
    label: str
    frame: int = 0
    finished: bool = False

    def update(self):
        if self.finished:
            return
        inp = self.strategy(self.frame, self.player)
        player_update(self.player, inp, self.tile_lookup)
        self.camera.update(self.player.physics.x, self.player.physics.y)
        self.frame += 1

    def draw(self):
        """Draw terrain + player using this bot's camera."""
        cam_x, cam_y = self.camera.x, self.camera.y
        pyxel.camera(cam_x, cam_y)
        draw_terrain(self.tile_lookup, cam_x, cam_y)
        draw_player(self.player)
```

Each `LiveBot` owns its own `Player`, `Camera`, and tile lookup. Multiple bots can run on
the same tile data with independent state. The `label` is rendered as a text overlay in the
bot's viewport (e.g., "HOLD_RIGHT").

### Strategy imports

The strategies live in `tests/harness.py` (from T-008-01). The live bot runner imports them
directly:

```python
from tests.harness import idle, hold_right, hold_right_jump, spindash_right
```

This is a dev-only path (gated by DEBUG), so importing from tests/ is acceptable. If the
import structure causes issues, the strategies can be extracted to a shared module later.

### Factory helpers

```python
def make_bot(tile_lookup, start_x, start_y, strategy, label) -> LiveBot:
    player = Player(start_x, start_y)
    camera = Camera()
    camera.reset(start_x, start_y)
    return LiveBot(player, strategy, tile_lookup, camera, label)

def make_bots_for_stage(stage_name: str) -> list[LiveBot]:
    """Create one bot per strategy for a real stage."""
    stage = load_stage(stage_name)
    sx, sy = stage.player_start
    return [
        make_bot(stage.tile_lookup, sx, sy, idle, "IDLE"),
        make_bot(stage.tile_lookup, sx, sy, hold_right, "HOLD_RIGHT"),
        make_bot(stage.tile_lookup, sx, sy, hold_right_jump, "JUMP"),
        make_bot(stage.tile_lookup, sx, sy, spindash_right, "SPINDASH"),
    ]

def make_bots_for_grid(tile_lookup, start_x, start_y, strategies) -> list[LiveBot]:
    """Create bots for a synthetic grid scenario."""
    ...
```

### Completion detection

A bot is "finished" when it has run for its max frames or reached a goal X. The caller sets
`max_frames` and optionally `goal_x`; the bot sets `self.finished = True` when either
condition is met. Finished bots stop updating but remain drawable (frozen at final frame).

### Location

`speednik/devpark.py` — the LiveBot class, factories, and dev park state management.
Keeping it in the game package (not tests/) because it imports Pyxel for rendering.

## Acceptance Criteria

- [ ] `LiveBot` dataclass with player, strategy, tile_lookup, camera, label, frame counter
- [ ] `LiveBot.update()` calls strategy → player_update → camera update each frame
- [ ] `LiveBot.draw()` renders terrain and player using the bot's own camera
- [ ] `make_bot` factory creates a LiveBot from tile_lookup + start position + strategy
- [ ] `make_bots_for_stage` creates 4 bots (idle, hold_right, jump, spindash) for a real
  stage
- [ ] `make_bots_for_grid` creates bots for a synthetic TileLookup
- [ ] Bot finishes after max_frames or reaching goal_x
- [ ] Finished bots stop updating but remain drawable
- [ ] Label string is accessible for HUD rendering
- [ ] Only imported/active when DEBUG is True
- [ ] No test regressions — `uv run pytest tests/ -x` passes
