---
id: T-010-10
story: S-010
title: scenario-runner-and-conditions
type: task
status: open
priority: high
phase: research
depends_on: [T-010-09]
---

## Context

Implement `run_scenario()` — the function that executes a scenario definition to completion,
checking success/failure conditions each frame and collecting a trajectory.

See `docs/specs/scenario-testing-system.md` §6.1 for the reference implementation.

### run_scenario function

```python
def run_scenario(scenario_def: ScenarioDef) -> ScenarioOutcome:
    sim = create_sim(scenario_def.stage)

    if scenario_def.start_override:
        sim.player.physics.x = scenario_def.start_override.x
        sim.player.physics.y = scenario_def.start_override.y

    agent = resolve_agent(scenario_def.agent, scenario_def.agent_params)
    agent.reset()

    trajectory = []
    for frame in range(scenario_def.max_frames):
        obs = extract_observation(sim)
        action = agent.act(obs)
        inp, prev = action_to_input(action, prev_jump)
        prev_jump = prev
        events = sim_step(sim, inp)
        reward = compute_reward(sim, events)

        trajectory.append(FrameRecord(...))

        success, reason = check_conditions(scenario_def, sim, trajectory)
        if success is not None:
            break

    return ScenarioOutcome(...)
```

### ScenarioOutcome and FrameRecord

```python
@dataclass
class FrameRecord:
    frame: int
    x: float
    y: float
    x_vel: float
    y_vel: float
    ground_speed: float
    angle: int
    on_ground: bool
    state: str
    action: int
    reward: float
    rings: int
    events: list[str]

@dataclass
class ScenarioOutcome:
    name: str
    success: bool
    reason: str
    frames_elapsed: int
    metrics: dict[str, Any]
    trajectory: list[FrameRecord]
    wall_time_ms: float
```

### Condition checker

```python
def check_conditions(
    scenario: ScenarioDef,
    sim: SimState,
    trajectory: list[FrameRecord],
) -> tuple[bool | None, str | None]:
    """Check success and failure conditions.
    Returns (True, reason) for success, (False, reason) for failure, (None, None) if
    neither triggered yet."""
```

Implements all 8 condition types from the spec. The `stuck` condition checks position
variance over a sliding window — reuses the concept from harness's `stuck_at()`.

### Determinism

The simulation is deterministic — same scenario definition run twice must produce identical
trajectories. Write a test that runs a scenario twice and asserts byte-for-byte identical
FrameRecord lists.

### Location

- `speednik/scenarios/runner.py` — run_scenario, ScenarioOutcome, FrameRecord
- `speednik/scenarios/conditions.py` — extend with check_conditions implementation
- `tests/test_scenarios.py` — new file

## Acceptance Criteria

- [ ] `run_scenario` executes a ScenarioDef and returns ScenarioOutcome
- [ ] Start override repositions player before running
- [ ] Agent resolved from registry and reset before run
- [ ] Per-frame FrameRecord collected in trajectory
- [ ] Success condition `goal_reached` triggers on goal event
- [ ] Success condition `position_x_gte` triggers on x threshold
- [ ] Success condition `alive_at_end` triggers at max_frames
- [ ] Failure condition `player_dead` triggers on death
- [ ] Failure condition `stuck` triggers on position stall
- [ ] Compound `any` failure condition works
- [ ] `wall_time_ms` measured via `time.perf_counter`
- [ ] Determinism test: two runs of same scenario produce identical trajectories
- [ ] Test: `hillside_complete.yaml` runs to completion without errors
- [ ] No Pyxel imports
- [ ] `uv run pytest tests/test_scenarios.py -x` passes
