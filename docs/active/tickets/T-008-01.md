---
id: T-008-01
story: S-008
title: scenario-runner-and-strategies
type: task
status: open
priority: high
phase: done
depends_on: []
---

## Context

Build the core scenario runner: a function that places a player in a stage, feeds inputs
frame-by-frame via a strategy function, and returns a trajectory log. Everything is
Pyxel-free. This is the foundation all other robotic-player tests build on.

### Scenario runner

```python
@dataclass
class FrameSnapshot:
    frame: int
    x: float
    y: float
    x_vel: float
    y_vel: float
    ground_speed: float
    angle: int
    on_ground: bool
    quadrant: int
    state: str  # PlayerState value

@dataclass
class ScenarioResult:
    snapshots: list[FrameSnapshot]
    player: Player  # final player object

    @property
    def final(self) -> FrameSnapshot:
        return self.snapshots[-1]

    @property
    def max_x(self) -> float:
        return max(s.x for s in self.snapshots)

    @property
    def quadrants_visited(self) -> set[int]:
        return {s.quadrant for s in self.snapshots}

    def stuck_at(self, tolerance: float = 2.0) -> float | None:
        """Return X where player was stuck, or None if they kept moving."""
        ...

def run_scenario(
    tile_lookup: TileLookup,
    start_x: float,
    start_y: float,
    strategy: Callable[[int, Player], InputState],
    frames: int = 600,
    *,
    on_ground: bool = True,
) -> ScenarioResult:
    ...
```

The runner calls `player_update(player, strategy(frame, player), tile_lookup)` each frame
and appends a `FrameSnapshot`. It does not import Pyxel.

An overload or helper `run_on_stage(stage_name, strategy, frames)` loads a real stage and
starts the player at `stage.player_start`.

### Strategy primitives

Each strategy is a callable `(frame: int, player: Player) -> InputState`.

**`idle`** — Returns `InputState()` every frame. Tests ground adhesion.

**`hold_right`** — Returns `InputState(right=True)` every frame. The baseline "beginner
player" strategy. Most important single test: does holding right get you through the level?

**`hold_right_jump`** — Returns `InputState(right=True, jump_pressed=..., jump_held=True)`.
Jump is pressed once, held indefinitely (the "spam jump" player). `jump_pressed` is True
only on the first frame (and re-pressed after landing).

**`spindash_right`** — Crouches, charges spindash for N frames, releases, holds right.
Re-spindashes when speed drops below a threshold. This models the "power player" who
spindashes through obstacles.

**`scripted(timeline)`** — Takes a list of `(start_frame, end_frame, InputState)` tuples.
Returns the input for the active window. For precise frame-by-frame control.

### Location

`tests/harness.py` — the scenario runner and strategy functions. Imported by test files,
not a test file itself (no `test_` prefix). Alternatively `tests/conftest.py` fixtures if
that's cleaner, but a plain module is simpler for now.

## Acceptance Criteria

- [ ] `run_scenario` function takes tile_lookup, start position, strategy, frame count
- [ ] Returns `ScenarioResult` with per-frame `FrameSnapshot` list and final `Player`
- [ ] `ScenarioResult` provides `max_x`, `final`, `quadrants_visited`, `stuck_at` helpers
- [ ] `run_on_stage` helper loads a named stage and runs from player_start
- [ ] `idle` strategy implemented — returns empty input every frame
- [ ] `hold_right` strategy implemented — holds right every frame
- [ ] `hold_right_jump` strategy implemented — holds right + manages jump press/hold
- [ ] `spindash_right` strategy implemented — charge/release/run/re-dash cycle
- [ ] `scripted(timeline)` strategy implemented — frame-windowed input playback
- [ ] No Pyxel imports anywhere in the module
- [ ] Basic self-test: `run_scenario` with `idle` on a flat tile grid keeps player grounded
  for 60 frames
- [ ] Basic self-test: `run_scenario` with `hold_right` on a flat tile grid advances player
  X position
- [ ] `uv run pytest tests/ -x` passes
