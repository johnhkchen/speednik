# Design: T-012-08-BUG-01 — Hillside Loop Not Traversable

## Problem Recap

The player gets trapped oscillating on the approach ramp (tx=215, type=1 tiles
with Q1 angles 41-47) and never enters the actual loop tiles (tx=217+, type=5).
The root cause is that the approach ramp tiles have steep angles that trigger Q1
(right-wall) sensor mode, but their height arrays are slope-shaped, not wall-shaped,
causing the rightward floor sensor to produce oscillating snap distances.

## Option A: Replace Approach Ramp Tiles with build_loop()-Style Geometry

**Approach**: Replace the hillside loop tiles (both the approach ramp and the loop
itself) with tiles generated by `build_loop()` or similar angular-sampling logic.
Rewrite tiles at tx=214-235, ty=23-39 with synthetically generated loop geometry
that has smooth angle progressions and matching height arrays.

**Pros**:
- Produces the same geometry that already works in synthetic tests
- Complete fix — no half-measures or edge cases
- build_loop() already handles all quadrant transitions, entry/exit ramps

**Cons**:
- Destroys the hand-placed visual design of the hillside loop
- The loop visual profile may not match the SVG-designed aesthetic
- Requires rebuilding both tile_map.json and collision.json data
- Invasive change to stage data

## Option B: Fix the Approach Ramp Angle Progression

**Approach**: Modify the approach ramp tiles (tx=214-216) to have Q0 angles instead
of Q1 angles, keeping the player in downward-sensor mode until it reaches the actual
loop tiles. The loop tiles at tx=217+ would then need to provide a smooth Q0→Q1
transition.

**Pros**:
- Minimal tile data change — only modifying ~6 tiles
- Preserves the loop's visual geometry

**Cons**:
- Just moving the problem: the player would reach the loop tiles but still face
  the Q0→Q1 transition there
- The loop tiles themselves may still have problematic angle progressions
- Doesn't address the fundamental issue of the angle progression through the arc

## Option C: Replace the Hillside Loop with Synthetic Loop at Load Time

**Approach**: In `load_stage("hillside")`, after loading tile_map.json, replace
the loop region tiles with synthetically generated ones from `build_loop()` using
an appropriate radius and center position. The replacement happens at runtime,
preserving the original tile_map.json for visual/editing purposes.

**Pros**:
- Uses proven build_loop() geometry that works in tests
- Doesn't modify tile_map.json on disk
- The synthetic loop can be tuned (radius, position) to match the visual layout
- Clean separation: visual data vs. collision data

**Cons**:
- Runtime tile replacement adds complexity to the loading path
- The synthetic loop shape may not perfectly overlay the visual tiles
- Need to calculate correct center and radius to match the existing visual arc
- Creates a divergence between tile_map.json and actual runtime collision

## Option D: Inject Synthetic Loop Tiles into tile_map.json and collision.json

**Approach**: Write a one-time script (or modify svg2stage.py) that replaces the
loop region in the hillside tile_map.json and collision.json with tiles generated
by `build_loop()` geometry. The replacement is baked into the data files.

**Pros**:
- Uses proven build_loop() geometry
- No runtime complexity — data files have correct geometry
- The tile_map.json becomes the source of truth for collision
- Can be verified by re-running the test suite

**Cons**:
- Requires a script to merge synthetic loop tiles into existing data
- Need to match the radius and position to the existing visual loop

## Decision: Option D — Bake Synthetic Loop Tiles into Stage Data

**Rationale**:

1. **Proven geometry**: build_loop() produces loops that pass the synthetic
   traversal tests. Using the same algorithm ensures consistency.

2. **One-time fix**: Modifying the data files is a permanent fix. No runtime
   overhead or loading-path complexity.

3. **Testable**: The existing test_loop_audit.py tests can verify the fix
   directly by running against the updated stage data.

4. **Matching the visual**: The hillside loop visual (from SVG) is approximately
   a 136px radius circle centered at pixel (3600, 496). We can compute the
   exact center and radius from the existing tile positions and generate
   matching collision tiles.

**Implementation strategy**:
- Write a script that loads the hillside tile_map.json and collision.json
- Identify the loop region (the existing type=5 tiles plus the approach ramp)
- Generate replacement tiles using build_loop()-style angular sampling
- The replacement tiles will have type=5 (SURFACE_LOOP), correct angles,
  correct height arrays, and appropriate solidity (FULL for walls, TOP_ONLY for
  top arc)
- Also include approach and exit ramp tiles with smooth Q0→Q1 transitions
- Write the modified data back to the JSON files

**Key parameters to determine**:
- Loop center: approximately pixel (3600, 504) based on the existing tile midpoint
  between tx=217 (left wall) and tx=233 (right wall), ty=23 (top) and ty=39 (bottom)
- Loop radius: (233-217) * 16 / 2 = 128 pixels
- Entry/exit ramp radius: ~32 pixels (2 tiles)
- Ground row: ty=39 (the inner floor of the loop is at ty=39, matching the
  existing flat ground tiles)

**Scope exclusions**:
- We will NOT modify the physics engine or sensor system
- We will NOT change build_loop() — we'll use its algorithm directly or adapt it
- We will NOT touch other stages (pipeworks, skybridge)
