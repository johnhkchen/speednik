---
id: S-008
title: robotic-player-test-harness
type: story
status: open
priority: high
tickets: [T-008-01, T-008-02, T-008-03, T-008-04]
---

## Goal

Build a deterministic test harness where "robotic players" — automated agents that interact
with the game only through the controls a real player has — exercise the physics engine
against synthetic and real terrain to find soft-locks, validate traversability, and establish
the mechanical boundaries of the engine.

## Background

The loop bug (S-007) was only discovered by manual playtesting. The existing test suite has
unit tests for individual physics functions and smoke tests for stage loading, but nothing
that simulates actual gameplay: a player spawns, holds right, hits an obstacle, tries to
jump over it. The game's architecture makes this unusually tractable:

- `player_update(player, inp, tile_lookup)` is fully Pyxel-free
- `InputState` has 6 booleans: `left`, `right`, `jump_pressed`, `jump_held`, `down_held`,
  `up_held` — tiny input space
- `PhysicsState` is a flat dataclass: position, velocity, angle, on_ground — fully
  inspectable every frame
- Pyxel's `pget()` reads rendered pixels without needing a game loop — visual assertions
  are possible for rendered frame tests later

The key principle: **the robotic player only inputs through controls the real player has.**
No teleporting, no state injection, no god mode. If the robotic player can't get past an
obstacle, neither can a human.

## Primitive Elementals

The first deliverable is a set of micro-scenarios built from synthetic tile grids that
isolate one mechanic at a time. These establish the engine's mechanical envelope:

**Walkability threshold** — At what surface angle does `hold_right` stop working? Build a
ramp from 0° to 90° and find the angle where the player stalls or detaches. This number
defines what slopes are passable by walking and must match the Sonic 2 reference (the player
should stick to slopes up to ~45° and transition to wall mode beyond that).

**Speed gate** — Given a steep slope or wall, what minimum speed clears it? Build an
obstacle and test walk speed (6.0), spindash speed (8.0+), and downhill-boosted speed. This
validates that speed-gated obstacles are calibrated correctly.

**Loop entry envelope** — Given a loop of radius R with an entry ramp, what combinations of
entry speed and ramp geometry result in successful traversal? This directly validates S-007's
ramp design: if the robotic player can spindash through a loop with ramps but not without
them, the ramps are working.

**Gap clearing** — What's the maximum gap width clearable at walk, run, and spindash speed
with a jump? This sets the design vocabulary for level gaps.

**Ground adhesion** — Does the player fall through the floor? Place the player on flat
ground, run 600 frames of `idle`, verify `on_ground` stays True and Y doesn't change. Then
repeat on slopes, on tile boundaries, on loop tiles. This catches subtle collision bugs.

## Soft-lock detection

The elementals establish what the engine can do. Soft-lock detection tests what levels
actually require. For each real stage, run multiple strategies and check whether the player
reaches the goal:

```
hold_right          → Stage 1 should be completable
hold_right + jump   → Stage 2 should be completable
spindash + jump     → Stage 3 should be completable (boss aside)
```

If multiple strategies all stall at the same X coordinate, that's a structural blockage.
If only `hold_right` fails but `spindash` passes, that's an intentional speed gate (valid
for loops, not valid for Stage 1's first hill).

## DAG

```
T-008-01  (scenario runner + strategies — the core)
   ├──→ T-008-03  (elemental terrain tests)
   └──→ T-008-04  (level soft-lock detection)

T-008-02  (synthetic tile grid builders — independent data helpers)
   └──→ T-008-03
```

T-008-01 and T-008-02 are independent and can run in parallel.
T-008-03 depends on both (runs strategies against synthetic grids).
T-008-04 depends on T-008-01 only (runs strategies against real stage data).
