---
id: S-009
title: dev-park-visual-test-arena
type: story
status: open
priority: medium
tickets: [T-009-01, T-009-02, T-009-03, T-009-04, T-009-05]
---

## Goal

Add a "Dev Park" level series — debug-only stages that render the S-008 robotic player
scenarios on screen so developers can watch bots exercise the physics engine in real time.
Instead of test results buried in terminal output, the dev park makes the mechanical envelope
*visible*: ramp walkers stalling at the threshold angle, spindashers blasting through loops,
hold-right players falling into gaps. A security-camera multi-view shows several strategies
running simultaneously for instant visual comparison.

## Background

S-008 builds a Pyxel-free test harness that runs robotic players against synthetic grids and
real stages. The results are `ScenarioResult` objects — frame-by-frame snapshots of position,
velocity, angle, and state. These are perfect for headless CI, but developers also need to
*see* what's happening: is the bot clipping through a wall? Does the spindash trajectory look
right? Is the loop entry smooth or jittery?

The game already has everything needed:

- **Stage registry** — hardcoded dict in `main.py` (`_STAGE_LOADER_NAMES`, `_STAGE_NAMES`).
  Adding stage 0 (or stage 4) for dev park is trivial.
- **Tile lookup abstraction** — `run_scenario` accepts any `TileLookup` callable, and so does
  `draw_terrain`. The synthetic grid builders from T-008-02 produce compatible lookups.
- **Pyxel rendering** — `draw_terrain`, `draw_player`, camera system all work with any tile
  data. No special rendering needed for synthetic grids.
- **256×224 screen** — fits a quad-split (4 × 128×112) or a main + sidebar layout.

The key insight: **the test harness and the renderer share the same data model.** A
`ScenarioResult` contains everything needed to replay a bot's run visually — or, better yet,
run the bot live and render each frame as it happens.

## Design

### DEBUG gate

A `DEBUG` flag (environment variable `SPEEDNIK_DEBUG=1`) unlocks the dev park in the stage
select menu. When disabled, dev park stages don't appear — zero impact on the player-facing
game. The flag also enables a debug HUD overlay (frame counter, player state, velocity vector)
useful during normal gameplay.

### Dev Park stages

The dev park is a series of sub-levels, each rendering one test scenario category from S-008:

1. **Ramp Walker** — Walkability threshold sweep. Shows a bot walking up ramps of increasing
   angle. Visual: the bot progresses until it stalls, with an angle readout at each ramp.
2. **Speed Gate** — Walk vs spindash on a steep obstacle. Two bots side-by-side: walker
   blocked, dasher clears it.
3. **Loop Lab** — Loop traversal with and without ramps. Shows the S-007 fix in action.
4. **Gap Jump** — Parametrized gaps. Bots attempt jumps at different gap widths.
5. **Real Stage Replay** — Runs `hold_right` (and other strategies) on the actual hillside
   stage, camera following the bot.

Each sub-level is navigable from a dev park menu (UP/DOWN to select, Z to watch).

### Security-camera multi-view

The marquee feature: a quad-split view running four strategies simultaneously on the same
terrain. Each quadrant shows a different bot (idle, hold_right, hold_right_jump, spindash)
with a label. The camera in each quadrant follows its own bot independently.

```
┌──────────┬──────────┐
│  IDLE    │  RIGHT   │
│  (stuck) │  (moving)│
├──────────┼──────────┤
│  JUMP    │ SPINDASH │
│  (moving)│  (fast)  │
└──────────┴──────────┘
```

Each pane is 128×112. Rendered by running 4 independent player instances with 4 independent
cameras, drawing each into its quadrant via `pyxel.clip()` + camera offset.

### Live bot runner

Unlike the headless harness which pre-computes all frames, the dev park runs bots live —
one `player_update` per frame per bot, rendered in real time. This reuses the strategy
functions from `tests/harness.py` but calls them from the game loop instead of a test runner.

The live runner is a thin adapter:

```python
class LiveBot:
    def __init__(self, tile_lookup, start_x, start_y, strategy):
        self.player = Player(start_x, start_y)
        self.strategy = strategy
        self.tile_lookup = tile_lookup
        self.frame = 0

    def update(self):
        inp = self.strategy(self.frame, self.player)
        player_update(self.player, inp, self.tile_lookup)
        self.frame += 1
```

### Debug HUD

When `SPEEDNIK_DEBUG` is set, an overlay shows:
- Frame counter
- Player X, Y, ground_speed, angle (byte)
- Player state (standing/running/rolling/spindash)
- Quadrant indicator
- on_ground flag

This works in both dev park stages and normal gameplay.

## DAG

```
T-009-01  (DEBUG flag + debug HUD overlay)
   └──→ T-009-02  (live bot runner — adapter from harness strategies to game loop)
           ├──→ T-009-03  (dev park stages — elemental scenarios rendered live)
           ├──→ T-009-04  (security-camera quad-split multi-view)
           └──→ T-009-05  (boundary escape detection — bots that walk off the map)
```

T-009-01 is independent (just a flag + HUD).
T-009-02 depends on T-009-01 (needs the flag) and on S-008's T-008-01 (needs strategies).
T-009-03 depends on T-009-02 (renders bots) and on S-008's T-008-02 (needs grid builders).
T-009-04 depends on T-009-02 (renders multiple bots simultaneously).
T-009-05 depends on T-009-02 (runs bots to level edges). Also adds headless tests to
`tests/test_levels.py` alongside T-008-04's soft-lock tests.
